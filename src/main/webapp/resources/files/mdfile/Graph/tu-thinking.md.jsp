<%@ page contentType="text/html; charset=UTF-8" %><p>title: 图的一些思考
date: 2017/7/27</p>
<hr />
<h2>aggregate 的改进</h2>
<p>如果说，在一个全局的图 aggregate 中，
节点在运行完一个 采集 函数后，便会去寻找周边一个 <code>已采集好的且需要被合并的</code> 然后找他合并。合并好了之后又会再去找一个 <code>已采集好的且需要被合并的</code>，直到全部合并完成。
A 节点最慢的话可以最后再做合并。这样的话相当于一个哈夫曼树。</p>
<h2>以边作为计算单元的话</h2>
<p>一定是后才
可以是多个边计算然后，作为一个 superstep 发送给 vertex 之后，vertex 计算完再发给 edge？</p>
<h2>超大图的用途？</h2>
<p>如果说超大图是有用的，那么它的用途在哪？</p>
<ol>
<li>社交网络</li>
<li>其他计算问题，可以转化为一个超大图模型进行计算。</li>
</ol>
<p>应该是社交关系网络图进行分析的一个工具。
进行社区分析。犯罪预测、高危发现、产品推荐之类的。</p>
<h2>如果</h2>
<p>如果算法 A 需要等到算法 B 结束或者或者执行到一半时才能执行，那么这算法怎么做？节点等还是不等
有没有这样的例子？</p>
<h2>速度</h2>
<p>一整个算法的结束由整体决定，而非单个节点的完成时间，所以有时间考虑着用空闲节点的时间获取忙碌节点的时间是很明智的。</p>
<h2>整体</h2>
<p>可不可以将多个节点视为一个团，一个顶点一个团的方式。团的方式解决了单个节点过大的问题，然后以团的方式进行以节点为中心的计算。</p>
<h2>master 与 mirror 模式</h2>
<p>master/mirror 模式中，是 A 作为 master，Bs 作为 mirror，那么 Bs 改变后的值则必须映射到 A 上，那么这种模式则必须锁定 A，因为 Bs 计算的镜像值是那时候的 A 的值，如果在 Bs 已经使用 k 时刻的 A 值进行计算，这时 A 又改变，那么 Bs 的计算就失效了。
可不可以这样，Bs 不锁定 A。
方法：Bs 在计算后，传给 A 几个东西，计算方法，计算的值，此次计算使用的 A 的版本信息。A 得到后，校验这些信息，如果 B 使用的是最新的，那么则直接更新，否则 A 再计算一遍，然后更新给其他 Bs。</p>
<p>这里是否再考虑一波，说可以设置多个这种用于记录的 A。然后 A 里一个队列，多次计算一次性计算。记录有版本号。</p>
<blockquote>
<p>Any changes to the vertex data (e.g., the Apply function) must be made to the master which is then immediately replicated to all mirrors.</p>
</blockquote>
<p>点切分，永远都需要解决的一点是通信量。即，镜像点的同步问题。</p>
<h2>机器学习的图计算，还那么需要考虑 power-law 吗？</h2>
