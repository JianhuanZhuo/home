<%@ page contentType="text/html; charset=UTF-8" %><p>手上的电脑再一次被搞挂了，不得不学习下 GRUB，在此做个笔记。</p>
<!--more-->
<p>GNU GRUB 是 <strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>ootloader 的简写，它是一种引导启动操作系统的引导加载器（bootloader），兼容 Linux、DOS、Windows 和 BSD。</p>
<h2>LILO</h2>
<p>LILO 是 <strong>LI</strong>nux <strong>LO</strong>ader 的简写。LILO 是另一种 Linux 加载器，但相对 GRUB 而言则没那么通用，而且存在比较多的限制，比如：</p>
<ol>
<li>引导实体数(boot entry) LILO 限制为 16 条，而 GRUB 无限制；</li>
<li>LILO 不支持网络引导，而 GRUB 支持；</li>
<li>LILO 无交互模式接口；</li>
</ol>
<h2>GRUB 工作模式</h2>
<p>在机器启动后，BIOS 会把控制权转交给第一个引导设备，这个设备可以是硬盘、软盘、光盘或者其他 BIOS 支持的设备，其中的第一也就是在 BIOS 管理界面设定的 <code>primary boot</code> 了。这里以硬盘为例子。</p>
<p>硬盘上第一块扇区 (sector) 称为主启动记录 MBR(Master Boot Record)，这个扇区的容量为 512 字节，且仅能存储 446 字节的主引导 (primary boot loader) 和 64 字节的分区表 (partition table)，分区表用于描述主分区和扩展分区信息。</p>
<p>而默认情况下，主启动记录 MBR 会查找活动分区 active partition，然后加载分区的引导扇区到内存中并将控制权转交给该分区。</p>
<p>而 GRUB 则是基于替换 MBR 的代码实现的。其具体机制如下：</p>
<ol>
<li>将 MBR 的代码替换为 stage1，stage1 指向 stage2，这么做的原因是 MBR 的可用空间确实太小；</li>
<li>stage2 指向一个配置文件，这个配置文件包含有复杂的用户接口和选项。如果 sstage2 无法找到配置文件，则 GRUB 会终止引导，并向用户提供一个命令行界面以便手动配置。</li>
</ol>
<p>这种指向结构，允许 GRUB 可以使用更大的空间来构造复杂而高级的启动配置。</p>
<h2>GRUB 设备标记</h2>
<p>GRUB 的标记与 Linux 的十分类似，如下一个简单的例子：</p>
<pre><code class="language-grub">(hd0,1)
</code></pre>
<p>需要注意的有如下：</p>
<ol>
<li>GRUB 菜单中的所有设备都必须使用括号括起来；</li>
<li><code>hd</code> 表示硬盘设备 <code>hard disk</code>，类似的，<code>fd</code> 表示软盘设备 <code>floppy disk</code>，<code>cd</code> 表示光盘 <code>CD-ROM</code> 等，GRUB 不区分 IDE 和 SCSI 驱动和主逻辑分区；</li>
<li>第二个数字表示该设备上的分区号，分区号是从 0 开始计算的，所以 1 表示第 3 个设备。</li>
</ol>
<p>需要注意的是，主分区的标号占 0 至 3 四个数字，如 (hd?,0) (hd?,1) (hd?,2) (hd?,3)，其中不管主分区是否有四个，逻辑分区都是由 4 开始算起。</p>
<h2>注释标记</h2>
<p>GRUB 配置文件中以 <code>#</code> 作为注释标记，一般的如果是文本推荐使用 <code>###</code>，而代码段使用 <code>#</code>。</p>
<h2>加载标记</h2>
<p>如下是配置文件 menu.lst 的简单实例：</p>
<pre><code class="language-grub">### grub.conf generated by anaconda
###
### Note that you do not have to rerun grub after making changes to this file
### NOTICE:  You have a /boot partition.  This means that
###          all kernel and initrd paths are relative to /boot/, eg.
###          root (hd0,0)
###          kernel /vmlinuz-version ro root=/dev/mapper/vg_myheart4-lv_root
###          initrd /initrd-[generic-]version.img
###boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title Red Hat Enterprise Linux (2.6.32-431.el6.x86_64)
	root (hd0,0)
	kernel /vmlinuz-2.6.32-431.el6.x86_64 ro root=/dev/mapper/vg_myheart4-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_myheart4/lv_root rd_LVM_LV=vg_myheart4/lv_swap rd_NO_MD SYSFONT=latarcyrheb-sun16  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-431.el6.x86_64.img

</code></pre>
<p>$$e^x$$</p>
<pre><code class="language-grub">default 0
timeout 8
</code></pre>
<p>写在配置文件开头的如上配置，<code>default 0</code> 表示菜单列表中的第一项将作为启动默认项，而 <code>timeout 8</code> 则表示用户选择其他启动项的等待时间为 8 秒。</p>
<pre><code class="language-grub">title openSUSE 10.2
root (hd0,2)
kernel /boot/vmlinuz-...
initrd /boot/initrd.img-...
</code></pre>
<p>如上配置表示菜单的一个启动项：</p>
<ol>
<li><code>tilte</code> 表示界面上菜单项的文字标题</li>
<li><code>root</code> 指定配置文件所在的位置，在这个实例中则指定 <code>(hd0,2)/boot/grub</code></li>
<li><code>kernel</code> 引导内核映像</li>
<li><code>initrd</code> 系统预备的临时文件系统，用于文件系统真正被加载之前适配硬件</li>
</ol>
<pre><code class="language-grub">title Windows
rootnoverify (hd0,0)
chainloader (hd0,0)+1
</code></pre>
<ol>
<li><code>rootnoverify (hd0,0)</code> 由于 OpenSUSE 无法识别 Windows 操作系统，而直接调用该分区；</li>
<li><code>chainloader (hd0,0)+1</code> 这个特性用于无法直接引导的操作系统，这些操作系统使用 <code>chainloader</code> 引导器进行引导，也就是 GRUB 将控制权转交给个另一个引导器了，而 <code>(hd0,0)</code> 则表示该引导器的安装位置。</li>
</ol>
<h2>GRUB 配置</h2>
<p>如果安装有 GRUB，那么配置文件应该放置在：<code>/boot/grub/menu.lst</code></p>
<p>设置为 GRUB 根设备到指定分区，如下为 <code>(hd0,1)</code>，并将信息写入 MBR 中：</p>
<pre><code class="language-grub">root (hd0,1)
setup(hd0)
quit
</code></pre>
<p>参考：<a href="www.dedomedo.com/computers/grub-2.html">GRUB 2 bootloader - Full tutorial</a></p>
<h2>GRUB RESCUE 模式</h2>
<blockquote>
<p>In rescue mode, only the insmod, ls, set, and unset commands are normally available.</p>
</blockquote>
<p>救援模式下，仅 insmode/ls/set/unset 命令有效。</p>
